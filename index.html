<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Fql by Journeyman08</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Fql</h1>
        <p></p>

        <p class="view"><a href="https://github.com/Journeyman08/FQL">View the Project on GitHub <small>Journeyman08/FQL</small></a></p>


        <ul>
          <li><a href="https://github.com/Journeyman08/FQL/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/Journeyman08/FQL/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/Journeyman08/FQL">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="fql" class="anchor" href="#fql" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FQL</h1>

<p>FQL is a set of tools designed to support and extend a philosophy of writing SQL code.  The intended goal of combining these together 
is to allow the user to write SQL code that:</p>

<ul>
<li>Encapsualtes tables from logic</li>
<li>Allows interface based design</li>
<li>Enables code reuse</li>
<li>Is testable</li>
</ul>

<p>None of these goals are particularly controversial, indeed they are all things that we would expect in normal programming languages, but
they can be difficult to achieve in normal SQL.</p>

<h3>
<a id="philosophy" class="anchor" href="#philosophy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Philosophy</h3>

<p>One of the central claims of the philosophy is that maintainability and readability are more important that speed or efficiency.  For most analytics projects most of the time, taking an efficiency hit of 2-5x is not an issue, and in those cases where it is, it can be overcome by cacheing or better query planning.  By contrast, writing code that can be easily understood and modified is crucial. </p>

<p>A second claim is that sql code should be structured as closely as possible to business logic.  It is tempting to write sql code as one highly efficient block of code, but this rapidly descends into a big ball of mud that if difficult to deal with.  By keeping the code similar to the business logic, we can easily walk through the steps involved and get the involvement of domain experts who might not be coding experts</p>

<h3>
<a id="implementing-the-philosophy" class="anchor" href="#implementing-the-philosophy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementing the philosophy:</h3>

<p>If we accept this philosophy, how should we implement it?  The main tool for doing this is the common table expression (CTE).  CTEs 
are temporary tables that are created on the fly, and they have strong similarities to functions in functional languages.  Like functions, each CTE has a type definition.  The inputs to the CTE are the CTEs and tables that it depends on and the output is a set of tuples.  Also like functions, CTEs can be composed together to prodcue arbitrarily complex logic.</p>

<p>If we write our sql so that each major transformation takes place in a single CTE, we can gain the same advantages that we get from breaking up a program into functions.  We can reuse the same transformation in different places and across different sql queries, we only have to change the logic in one place rather than many different places, and we can test the particular piece of logic in isolation to the rest of the code.</p>

<h3>
<a id="fql-tooling" class="anchor" href="#fql-tooling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FQL Tooling:</h3>

<p>Managing all of these CTEs my hand is boring and pointless, so we needing tools to help us do this. Enter FQL</p>

<p>The first piece of tooling we need is a way to store queries for future use.  Using FQL we can break a big query apart into constituent parts and store it in a central repository:</p>

<div class="highlight highlight-source-python"><pre>sqlCode <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span> with companies as</span>
<span class="pl-s">                (</span>
<span class="pl-s">                    -- description</span>
<span class="pl-s">                    select company_id, name</span>
<span class="pl-s">                    from companies</span>
<span class="pl-s">                ),</span>
<span class="pl-s">                accounts as</span>
<span class="pl-s">                (</span>
<span class="pl-s">                    /* Im the accounts */</span>
<span class="pl-s">                    select account_id, name</span>
<span class="pl-s">                    from</span>
<span class="pl-s">                    testtable</span>
<span class="pl-s">                )</span>
<span class="pl-s">                select name</span>
<span class="pl-s">                from</span>
<span class="pl-s">                accounts</span>
<span class="pl-s">        <span class="pl-pds">"""</span></span>
code <span class="pl-k">=</span> SqlCode(sqlCode)
repo <span class="pl-k">=</span> Repository(<span class="pl-s"><span class="pl-pds">"</span>repo.pickle<span class="pl-pds">"</span></span>)
repo.add_queries(code.queries)
repo.save()</pre></div>

<p>Note that the comments at the start of the ctes act like doc strings, they are stored as query.description</p>

<p>Of course, storing the queries is only half the battle, we also need the ability to retrieve them on command.  There are two ways to do this depending on whether or not you know the exact name of the CTE.</p>

<p>If you do, you can bring it back like:</p>

<div class="highlight highlight-source-python"><pre>repo <span class="pl-k">=</span> Repository(<span class="pl-s"><span class="pl-pds">"</span>repo.pickle<span class="pl-pds">"</span></span>)
repo.retrieve_query(<span class="pl-s"><span class="pl-pds">"</span>accounts<span class="pl-pds">"</span></span></pre></div>

<p>If you don't, you can have the repoistory return the best guess as to the query you want based on keywords and the information based in the query name and description:</p>

<div class="highlight highlight-source-python"><pre>repo <span class="pl-k">=</span> Repository(<span class="pl-s"><span class="pl-pds">"</span>repo.pickle<span class="pl-pds">"</span></span>)
searcher <span class="pl-k">=</span> RepositorySearcher(repo)
found <span class="pl-k">=</span> searcher.get_best_guesses(<span class="pl-s"><span class="pl-pds">"</span>accounts<span class="pl-pds">"</span></span>)</pre></div>

<p>Once you have the CTE that you are looking for, you can turn it into a runnable piece of SQL using the QueryGenerator class:</p>

<div class="highlight highlight-source-python"><pre>repo <span class="pl-k">=</span> Repository(<span class="pl-s"><span class="pl-pds">"</span>repo.pickle<span class="pl-pds">"</span></span>)
qg <span class="pl-k">=</span> QueryGenerator(repo)
sql <span class="pl-k">=</span> qg.generate_query(query.name)</pre></div>

<p>This will search through the repository for the query, find all the other ctes which the query depends on and produces a sql query string needed to run the CTE.</p>

<h4>
<a id="testing" class="anchor" href="#testing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Testing</h4>

<p>FQL provides a great setup to test your CTEs.  To keep the tests as closely inline with the data as possible, FQL does all of the testing through the same DB that your data sits on.  It creates a new schema (default name tests) with one table for each of your CTEs.  To add a tests, simply insert the test input data into the relevant input CTEs and the expected output values into the appropriate tables.  FQL will scan through the tables for each test and identify exactly which CTEs can be tested using the information you inserted.</p>

<p>The first time you use the testing, FQL provides a helper function setup_repository_test_suite() to create the schema and all of the necessary tables.  You will need to rerun this if you update the CTEs.</p>

<p>To run tests use the code below.  You first load a repository and create a connection to your database.  Then specify which test ids you wish to run.  These correspond to the test_id columns in the tests schema tables.  Finally, you can either run all tests or limit to specific ids.</p>

<div class="highlight highlight-source-python"><pre>repo <span class="pl-k">=</span> Repository(<span class="pl-s"><span class="pl-pds">"</span>repo6.pickle<span class="pl-pds">"</span></span>)
test <span class="pl-k">=</span> RepositoryTest(conn, repo, <span class="pl-s"><span class="pl-pds">"</span>tests<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>)
<span class="pl-c">#run one test</span>
<span class="pl-c1">print</span>(test.run())
<span class="pl-c">#Run tests 1 to 10</span>
tests <span class="pl-k">=</span> [RepositoryTest(conn, repo, <span class="pl-s"><span class="pl-pds">"</span>tests<span class="pl-pds">"</span></span>, x <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">for</span> x <span class="pl-k">in</span> <span class="pl-c1">range</span>(<span class="pl-c1">10</span>)]
tester <span class="pl-k">=</span> RepositoryTester(conn, [tests])
<span class="pl-c1">print</span>(tester.run_all_tests())</pre></div>

<p>The final line will print a list of all test ids that failed (i.e. where the expected values inserted into the tests schema tables didn't equal the output of the run CTE).</p>

<h4>
<a id="intergrating" class="anchor" href="#intergrating" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Intergrating:</h4>

<p>FQL aims to integrate into your current workflow to make life as easy as possible.  At the moment, it can be hooked to export data to the file system and into valid lookML files.  </p>

<p>This is part of the project which will expand the most quickly to enable FQL to coordinate and manage lookML projects</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/Journeyman08">Journeyman08</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
